---
title: '芯片分类：芯片通识课笔记'
date: 2026-02-07
permalink: /posts/2026/02/blog-post-1/
tags:
  - category1
  - category2
  - category3
---

> 芯片分类：芯片通识课笔记

## 芯片分类

### 数字电路芯片

1. 逻辑电路芯片：实现逻辑运算的芯片，如与门、或门、非门等。
2. 通用处理器芯片：如CPU、GPU等，执行各种计算任务。
3. 存储芯片：如RAM、ROM等，用于数据存储。
4. 片上系统芯片（SoC）：集成了CPU、内存、外设等功能的芯片，如智能手机、平板电脑等。
5. 微控制器芯片（MCU）：简化版SoC，也被称为单片机，用于控制和执行特定任务，如嵌入式系统。
6. 专用集成电路芯片（ASIC）：用于特定应用的集成电路芯片，如通信芯片、图像处理器等。
7. 可编程逻辑器件芯片（FPGA）：可编程的逻辑器件芯片，用户可以根据需求进行配置和编程。

MCU和SoC的区别不大，其实只是集成度不同。SoC集成度高，包含了CPU、内存、外设等多个功能模块，而MCU集成度低，通常只包含CPU、内存和一些外设。所以手机也是一个嵌入式系统。

感觉NPU本质是一个AISC，目前在逐渐向通用处理器芯片方向发展。

### 模拟电路芯片

1. 分立器件和模组：如二极管，三极管等。
2. 电源电路芯片：用于电源管理，电压变换，充电管理等。
3. 信号检测电路芯片：用于检测和处理微弱电信号。
4. 滤波器芯片：如低通滤波器、高通滤波器、带通滤波器等，用于信号处理。
5. 转换电路芯片：如电压转换器、电流转换器等，用于信号转换。
6. 信号发生器芯片：如正弦波发生器、方波发生器等，用于生成特定的模拟信号。
7. 放大器芯片：如运算放大器、功率放大器等，用于信号放大。

### 数模混合芯片

1. 模-数转换器芯片：ADC和DAC等，用于将模拟信号和数字信号进行转换。
2. 光电转换芯片：如光电传感器、光电二极管等，用于将光信号转换为电信号。
3. 基带芯片：用于处理基带信号的芯片，如4G，5G等芯片。
4. 调制解调芯片：如调制解调器、解调解调器等，用于信号的调制和解调。
5. 接口电路芯片：用于芯片内部，芯片和外部设备之间的接口电路芯片，如USB接口芯片、HDMI接口芯片等。
6. 传感器芯片：如温度传感器、压力传感器等，用于检测环境参数并输出模拟或数字信号。
7. 驱动器芯片：如LED驱动器、电机驱动器等，用于驱动外部设备。

### 特种电路芯片

1. 军工级芯片：用于军事领域的芯片，具有高可靠性和安全性。
2. 射频功率芯片：用于射频信号的功率放大和处理，如射频放大器、射频电源等。
3. 超高压芯片：用于处理高电压信号的芯片，如高电压开关、高电压转换器等。

## 存储芯片

### RAM

1. SRAM：用于缓存
2. DRAM，double DRAM，LPDDR，GDDR，HBM等：用于内存条

### ROM

其实ROM变化还挺多的，逐渐变得**可读可写**了，要不然固件怎么升级呢？只不过主板厂商为了防止用户乱改，一般会把写保护打开。

1. ROM，PROM，EPROM，EEPROM
2. Flash ROM（闪存）NOR Flash，NAND Flash
   1. 目前UEFI/BIOS主流存储介质
   2. 手机/平板电脑等嵌入式设备的主流存储介质：UFS，eMMC
   3. 也是SSD的主要存储介质：NVMe SSD，SATA SSD
      1. 插在SATA接口上的SSD，速度较慢
      2. 插在M.2接口上的SSD，速度较快，但是协议不同，分为NVMe和SATA两种，前者速度更快，直接走**PCIe总线**
   4. U盘：USB闪存盘
   5. SD卡：SD，microSD等
3. HDD：插在SATA上，走南桥芯片组；机械硬盘，所以需要有磁头和马达等机械结构，速度慢
4. 文物
   1. 光盘：机械结构，CD，DVD，蓝光等；分为只读的和可读写的
   2. 磁带：机械结构，速度慢，主要用于备份和归档
   3. 软盘：机械结构，速度慢，已经淘汰了

## 制作系统和启动盘过程

TL;DR：

1. windows：win11 ISO + 官方Media Creation Tool
2. linux：ubuntu ISO + Rufus

### 技术细节

1. 对于被安装的电脑，bios被主板厂商控制，基本只能升级，自己无法修改，但是可以修改启动项的，这一步没有修改bios程序，而是修改了bios的设置
   1. 电脑本身有一个启动项，也就是硬盘，
   2. 重装系统需要从另一个启动项启动，也就是U盘或者光盘等
   3. 旧的电脑使用BIOS，所以需要MBR分区表，**新的电脑使用UEFI，所以需要GPT分区表**
2. 对于制作启动盘
   1. 根据1.3选择分区表，相当于给空白的书写上目录
   2. 还是因为bios的规则，首先读硬盘第一个扇区，也就是MBR，里面有一个分区表，告诉bios哪里是启动项；如果是UEFI，则bios会读取第二个扇区，也就是GPT，里面同样有一个分区表，一般是EFI分区，告诉bios哪里是启动项
   3. BIOS → 读MBR代码（446字节） → 代码加载活动分区引导扇区（bootloader加载内核） → 加载OS
   4. UEFI → 读GPT → 挂载EFI分区（FAT32）→ 直接执行.efi文件 → 加载OS
   5. 另一个要考虑的是文件系统，也就是书的内容组织方式，例如NTFS，FAT32，exFAT等
   6. grub以及windows boot manager等引导程序，负责加载内核和initramfs等文件就是bootloader
3. 如果使用命令行替代Rufus
   1. Rufus干了什么？
      1. 选择分区表（MBR或GPT）
      2. 格式化U盘（FAT32或NTFS等）
      3. 将ISO文件中的内容写入U盘
      4. 设置引导标志，使U盘成为可启动设备，本来的ISO是为了光盘设计的
   2. 这些用命令行：
      1. 分区表：使用`parted`或`fdisk`创建MBR或GPT分区表
      2. 格式化：使用`mkfs`命令格式化分区
      3. 写入ISO：使用`dd`命令将ISO文件写入U盘
      4. 设置引导标志：使用`parted`或`fdisk`设置分区为活动分区（MBR）或创建EFI分区（GPT）
4. 有真实的U盘，直接插上去会自动发现在/dev下，自动挂载，使用dd就可以复制ISO
   1. sudo dd if=./ubuntu.iso of=/dev/sdb bs=4M status=progress conv=fdatasync
5. ISO已经包含了grub的引导程序，但如果自己做操作系统，需要自己安装grub，除了安装grub之外，还需要编译内核，以及制作initramfs，安装过程就是将grub的引导程序写入MBR或EFI分区，并配置grub.cfg文件，告诉grub如何加载内核和initramfs等
6. 有真实的U盘，直接插上去会自动发现在/dev下，自动挂载，手工制作lunux系统
   1. sudo umount /dev/sdb*（相当于 Windows 的"安全弹出设备"）
   2. sudo parted /dev/sdb mklabel gpt，已经是相当于删除数据了
   3. sudo parted /dev/sdb mkpart primary fat32 1MiB 100%
   4. sudo parted /dev/sdb set 1 esp on
   5. sudo mkfs.fat -F32 /dev/sdb1，格式化，注意这里是sdb1，不是sdb，因为sdb是整个U盘，sdb1是第一个分区，插上就至少有一个分区
   6. 挂载并复制文件
   7. mkdir mnt
   8. sudo mount /dev/sdb1 mnt
   9. 复制kernel，initramfs，grub等文件到mnt
7. 如果没有真实的U盘，可以使用一个文件来模拟U盘
    1. 创建一个大文件，例如1GB：`dd if=/dev/zero of=usb.img bs=1M count=1024`
    2. 使用`losetup`命令将文件关联到一个环回设备：`sudo losetup /dev/loop0 usb.img`
    3. 然后对`/dev/loop0`进行**分区、格式化和复制文件，步骤与真实U盘类似**
    4. 完成后，使用`sudo losetup -d /dev/loop0`解除关联

### 开机

1. 装了系统之后，U盘的efi和系统被复制到了硬盘上，所以bios又回归到读取硬盘启动
2. 此时硬盘也是GPT分区表，bios读取GPT，挂载EFI分区，执行.efi文件，加载OS内核
3. OS内核被加载到内存中，开始执行，同时还有一些初始化工作，例如挂载根文件系统，启动init进程等，这些也占用一些内存
4. 剩下的操作系统文件和用户文件都存储在硬盘上，需要时从硬盘读取到内存中执行

### 参考：MBR vs GPT 详解

```text
MBR 硬盘空间
├── 扇区0: MBR (包含446字节代码 + 分区表)
├── (未使用空间，直到第一个分区开始)
├── 分区1 (例如C盘)
│   ├── **扇区X: 该分区的VBR (卷引导记录)**  ← 这是核心！
│   ├── 文件系统元数据 (如NTFS的$Boot)
│   ├── 操作系统文件
│   └── 用户可用空间
├── 分区2 (例如D盘)
│   ├── **扇区Y: 该分区的VBR** (如果此分区也可启动)
│   ├── 文件系统元数据
│   └── 用户可用空间
└── ...

GPT 硬盘空间
├── 扇区0: **保护性MBR** (仅为了让老工具识别，防止其破坏GPT)
├── 扇区1: **GPT主头** (包含分区表位置、备份位置等关键信息)
├── 扇区2-33: **GPT主分区表** (最多128个分区条目，每个128字节)
├── (对齐空闲，通常从扇区34开始)
├── 分区1: **EFI系统分区** (ESP，必须第一个，FAT32格式)
│   ├── EFI/
│   │   ├── /Boot/bootx64.efi (默认启动文件)
│   │   ├── /Microsoft/Boot/ (Windows启动文件)
│   │   └── /ubuntu/ (Ubuntu的GRUB文件)
│   └── (其他UEFI应用和驱动)
├── 分区2: **MSR分区** (微软保留，16MB，Windows专用)
├── 分区3: **主分区 (例如C盘)**
│   ├── 文件系统元数据 (如NTFS的$Boot) ← 无传统VBR！
│   ├── 操作系统文件
│   └── 用户可用空间
├── 分区4: **其他数据分区 (例如D盘)**
│   ├── 文件系统元数据
│   └── 用户可用空间
├── (更多分区...)
├── (磁盘末尾预留空间)
├── **GPT备份分区表** (主分区表的完整拷贝)
└── 最后一个扇区: **GPT备份头** (用于灾难恢复)
```