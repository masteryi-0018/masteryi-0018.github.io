---
title: "c++：一些细节知识"
date: 2025-09-16
permalink: /posts/2025/09/blog-post-1/
tags:
  - category1
  - category2
  - category3
---

> 回顾一下c++的一些知识，查漏补缺

## 第一章

1. linux系统中的cc链接到gcc，c++链接到g++

cc 是 很早以前 Unix 上的 C 编译器命令（最初是 PDP-11 上的 C 编译器）。后来 GNU 推出 GCC (GNU Compiler Collection) 时，为了兼容已有的习惯，把 cc 链接到 gcc，这样老的脚本和工具就不用改。

2. 结束符号EOF，linux是ctrl+D，Windows是ctrl+Z

3. for循环中，i++和++i的区别到底有多大？

如果是测试 int 的 i++ vs ++i，即使把 N 调大到几十亿，现代编译器优化后可能还是差别几乎为零。如果想看到明显差异，最好用 自定义类型或迭代器，因为那才会产生额外拷贝。

对于迭代器，it++ 会**创建一个临时迭代器对象**保存“原始位置”，然后再自增。++it 直接自增，不需要创建临时对象，效率更高。

注意，sum需要是volatile的。

4. std=c++11，std=c++0x是一个意思

C++98 是第一个正式的 C++ 标准（发布于 1998 年）。后续计划在 200x 年代初期（也就是“0x”，其中 x 代表某个具体数字）发布下一版标准。在标准还没定稿的时候，编译器厂商就开始提前支持一些候选特性。于是给这个版本起了个代号`0x`

5. 编译时开启-Wall并不是 all warnings（所有警告），而是 commonly used warnings（常用警告集合）。还可以开启-Wextra → 打开额外的警告。-Werror → 把警告当成错误（编译失败）。推荐开启 -pedantic-errors，将 -pedantic 找到的警告变为错误。

6. 输出时缓存区可能未刷新导致日志没有打印，记得加换行（\n或者endl）

## 第二章

1. c++11的新特性

- long long数据类型，列表初始化，nullptr
- const -> constexpr
- typedef -> using xx = x
- auto -> decltype(x)
- 类的成员函数初始化，以前只能用构造函数初始化列表或者构造函数里面初始化