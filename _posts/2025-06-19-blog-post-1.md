---
title: '计算机：操作系统的知识'
date: 2025-06-19
permalink: /posts/2025/06/blog-post-1/
tags:
  - category1
  - category2
  - category3
---

> 操作系统，操作系统内核那些事儿

## Linux kernel编译

### 前置准备

1. linux环境
   - WSL2 Ubuntu 20.04
   - 依赖：flex，bison，libelf-dev，libssl-dev等
   - 一键安装依赖可以参考<https://github.com/microsoft/WSL2-Linux-Kernel?tab=readme-ov-file#build-instructions>

2. 源码位置：
   - 进入<https://www.kernel.org/>，或者搜索Linux kernel找到这个
   - 使用git下载的话就点击git：<https://git.kernel.org/>
   - 有很多repo，从里面搜索Torvalds，找到`kernel/git/torvalds/linux.git`
   - 点进去下方就有下载方式，git clone或者wget *.tar.gz都可以，推荐wget，源码特别大

3. busybox
   - 用户空间的工具集，否则启动之后没有任何工具可以使用
   - 链接：<https://www.busybox.net/>
   - git clone，或者wget *.tar.bz2：`wget https://busybox.net/downloads/busybox-1.37.0.tar.bz2`

### 开始编译

1. 编译kernel
   - make defconfig
   - （optional）make menuconfig
   - make -j$(nproc)
   - 编译产物会显示：./arch/x86_64/boot/bzImage

2. 编译busybox
   - 从源码编译
   - make defconfig
   - make nemuconfig
   - 打开：Settings  ---> Build static binary (no shared libs)
   - 关闭：Networking Utilities  ---> tc (8.3 kb)
   - make -j$(nproc)
   - make install

3. 打包initramfiles
   - mkdir rootfs
   - cp -r busybox-1.37.0/_install/* rootfs/
   - vim init，内容如下
   - chmod +x init
   - find . | cpio -o -H newc | gzip > ../initramfs.cpio.gz

```sh
#!/bin/sh

echo "hello masteryi! this is your initramfs!"

/bin/sh
```

### 使用qemu仿真

1. 使用qemu仿真
   - sudo apt install qemu-system-x86
   - qemu-system-x86_64 -kernel linux-6.16-rc2/arch/x86_64/boot/bzImage -initrd initramfs.cpio.gz -nographic -append "console=ttyS0"
   - 可以看到日志出现了“hello masteryi! this is your initramfs!”
   - 使用`ctrl+A, x`退出qemu

### 替换WSL的内核

1. 将编译好的vmlinux拷贝到Windows下的路径

2. 设置.wslconfig，这一步只替换kernel，不影响发行版

```sh
# 查看状态，running的话关机
wsl -l -v

wsl --shutdown

vim ~/.wslconfig

wsl -d ubuntu
```

```sh
[wsl2]
kernel=D:\\project\\vmlinux
```

3. 查看2次的`uname -a`，发现kernel版本已经变了

### 替换WSL的用户空间

1. 将rootfs打包：`tar -zcvf ../initramfs.tar.gz .`
2. 拷贝到Windows下的路径
3. wsl --import mylinux D:\\project\\wsl_mylinux D:\\project\\initramfs.tar.gz
4. wsl -d mylinux

### 编译ISO镜像文件

1. sudo apt install isolinux syslinux genisoimage
2. make isoimage FDARGS="initrd=../initramfs.cpio.gz console=ttyS0" FDINITRD=../initramfs.cpio.gz
3. qemu-system-x86_64 -cdrom arch/x86/boot/image.iso -nographic

### 编译hd镜像文件

和编译ISO基本是一样的

1. sudo apt install ovmf（安装了还是找不到*** Need a shell.efi file for x64, please install EDK2/OVMF.）
2. make hdimage FDARGS="initrd=../initramfs.cpio.gz console=ttyS0" FDINITRD=../initramfs.cpio.gz
3. qemu-system-x86_64 -hda arch/x86/boot/hdimage -nographic

但是安装ovmf后还是没有shell.efi这个东西，似乎是ubuntu的已知问题，于是源码下载，发现master分支没有这个文件，只能通过已有的release链接下载：
- wget https://github.com/tianocore/edk2/blob/UDK2018/ShellBinPkg/UefiShell/X64/Shell.efi（无效）
- wget https://github.com/tianocore/edk2/raw/UDK2018/ShellBinPkg/UefiShell/X64/Shell.efi

GitHub 的 blob URL 会返回一个 HTML 页面（包含代码渲染），而不是二进制文件 Shell.efi。所以下载还是要用raw的。

- sudo cp Shell.efi /usr/share/OVMF

### 编译seabios

- git clone https://git.seabios.org/seabios.git（这个比较慢）
- git clone git@github.com:coreboot/seabios.git（github镜像，快一些）

```sh
cd seabios
make
qemu-system-x86_64 -bios out/bios.bin --nographic
```

### 问题

1. 为什么不能apt install busybox？如果这样安装的话，会有依赖本地的动态库：

```sh
$: ldd /usr/bin/busybox
linux-vdso.so.1 (0x00007fff0cff3000)
libresolv.so.2 => /lib/x86_64-linux-gnu/libresolv.so.2 (0x00007f8b0c435000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f8b0c243000)
/lib64/ld-linux-x86-64.so.2 (0x00007f8b0c514000)
```

2. 为什么需要手动设置busybox？如果动态链接，还是有一样的问题；tc这个是头文件，我也懒得继续debug了

## 安装操作系统

也就是通常讲的装系统，普罗大众会接触到的概念。给一个电脑安装操作系统，或者重装操作系统，最通常的情况是**制作U盘启动盘**。我们一般在另一个可以运行的电脑上下载对应的操作系统，这里一般是ISO，也就是镜像，这个镜像也不直接搞到对应电脑的硬盘中，所以我们用U盘是最省事的，但是这个ISO不能直接使用，需要将U盘制作为启动盘之后才可以使用。

启动盘的作用和以前使用光盘启动是类似的，只不过更加方便，直接将ISO解压到U盘不能用，因为这个引导程序（Bootloader）没有被放置在正确的位置上，导致无法被识别为一个操作系统。

在编译linux kernel的时候，有几个选项：
1. fd（软盘）
2. hd（硬盘）
3. cdrom（光盘）

使用qwmu仿真的时候，也有几个对应的选项：
1. kernel + initrd
2. fda
3. hda
4. cdrom

这里cdrom就是对应光盘，现在使用较少，而hd就是对应硬盘，U盘启动盘就是模拟硬盘的；又因为光盘和U盘天生不同，光盘是ROM，在**刻录**时，ISO镜像的引导信息会自动写入光盘的引导扇区，因此，只要直接刻录完整的系统ISO文件，光盘本身就具备启动能力。U盘是RAM，所以需要制作启动盘这一步。

### 给电脑安装

不论是PC或者笔记本，都属于x86架构的通用计算机，这里的通用基本是指拥有主板，cpu，gpu，内存，等组件的一个计算机。主板是哪个厂商的，主板上的bios芯片就是哪个厂商已经写好的烧录好的，我们可以制作操作系统启动盘，但也是由这个bios进行引导的，也就是我们控制了bootloader，os和kernel的部分。如果我们需要修改bios，需要专门写一个bios，并且通过烧录，移植到主板上面。

### 给手机安装

手机从概念上面讲，甚至是一个广义的嵌入式设备，我的理解就是以SoC为主导的主板高度集成，手机的bios/uefi也在SoC上只读，之后进入存储分区，开始bootloader以及Android的加载。但是手机厂商一般会将bootloader上锁，只有解锁了之后，才能有root权限，才能使用已有的bios/uefi安装自己的操作系统，很折腾。

### 给树莓派安装

计算机可以这么分：
- 通用计算机：PC，笔记本
- SBC（单板计算机）：树莓派，nv jetson等。有操作系统，实际上是一个微型计算机。
- MCU（单片机）：stm32，adruino。无操作系统，软件需要烧录运行

还有一些其他的：
- fpga：Xilinx的一些板子
- pynq/zynq：也是Xilinx的，但是使用了arm+fpga的异构体系

树莓派可以安装官方的操作系统，也可以安装ubuntu等linux发行版，所以应该也可以安装自己编译的linux系统，但不同的是，树莓派也是基于arm的架构，和手机一样，基于arm架构没有传统意义的bios/uefi，叫做bootrom，但实际上也一样，以后也就用bios指代这个启动过程。

### 启动过程

- 上电
- BIOS/UEFI：烧录在主板bios芯片，执行POST（硬件自检）等
- bootloader：lilo/grub，位于os镜像中，执行加载kernel
- kernel：接管资源，执行init进程，暴露shell给用户